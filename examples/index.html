<!--
  Copyright 2018 The Distill Template Authors

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!doctype html>

<head>
  <script src="template.v2.js"></script>
  <script src="three.js"></script>
  <script src="OrbitControls.js"></script>


  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_SVG">
</script>
<script src="https://cdn.plot.ly/plotly-2.4.2.min.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf8">

  <script type="text/bibliography">
    @book{hibbeler2017,
      title     = "Engineering Mechanics: Statics, 14th edition",
      author    = "Russel Hibbeler",
      year      = 2017,
      publisher = "Pearson",
      address   = "Essex"
    }
  </script>

  <style>
    .grid-container {
      display: grid;
      grid-template-columns: auto auto auto;
      /* background-color: #2196F3; */
      padding: 10px;
      margin: 0px;
    }
    .grid-item {
      background-color: rgba(255, 255, 255, 0.8);
      /* padding: 20px; */
      /* font-size: 30px; */
      text-align: center;
    }

    .center {
      display: block;
      margin-left: auto;
      margin-right: auto;
      width: 100%;
    }
    </style>
</head>

<body>
  <!-- <distill-header></distill-header> -->
  <d-front-matter>
    <script id='distill-front-matter' type="text/json">{
    "title": "Cartesian vectors and coordinate direction angles",
    "description": "Although \" extremely useful for visualizing high-dimensional data, t-SNE plots can sometimes be mysterious or misleading.",
    "published": "19 October, 2021",
    "authors": [
      {
        "author":"Shane Josias",
        "authorURL":"https://appliedmaths.sun.ac.za/~josias",
        "affiliations": [{"name": "Stellenbosch University"}]
      }
    ],
    "katex": {
      "delimiters": [
        {"left": "$$", "right": "$$", "display": false}
      ]
    }
  }</script>
  </d-front-matter>
  <d-title>
    <!-- <figure style="grid-column: page; margin: 1rem 0;"><img src="header.png"
        style="width:50%; border: 1px solid rgba(0, 0, 0, 0.2);" /></figure> -->
    <p>This article allows the reader to interactively manipulate components of a vector and observe the changes in the cordinate direction angles. 
      It is my hope that it may provide an intuition about coordinate direction angles.</p>
  </d-title>
  <d-byline></d-byline>

  <d-article >
    <!-- <a class="marker" href="#section-1" id="section-1"><span>1</span></a> -->
    <h1>Cartesian vectors recap</h1>
  
    <p>
      A vector $$\mathbf{A}$$ can be represented in cartesian form as:
      
      <d-math block>
         
        \mathbf{A} = A_{x}\mathbf{i} + A_{y}\mathbf{j} + A_{z}\mathbf{k},
      </d-math>

      where $$A_x$$, $$A_y$$, and $$A_z$$ are the $$x$$, $$y$$, and $$z$$ components of the vector. We can also calculate a vector's magnitude using the following equation
     

      <d-math block>
        A = \sqrt{A_{x}^2 + A_{y}^2 + A_{z}^2}.
      </d-math>
    
    </p>

    <h1>Coordinate direction angles</h1>

    <p>
     The direction of $$\mathbf{A}$$ can be defined by the coordinate direction angles $$\alpha$$, $$\beta$$ and $$\gamma$$, 
     measured between the tail of $$\mathbf{A}$$ and the positive $$x$$, $$y$$, $$z$$ axes. Figure 2-26 in the textbook ilustrates this idea:

     <figure style="margin: 1rem 0;">
      <img class = "center" src="coordir.png"
        style="width:30%; border: 1px solid rgba(0, 0, 0, 0.2);" />
        <figcaption style="text-align: center; bottom: 0px; margin-top: 5px ;">Figure 2-26, taken from the Engineering Mechanics: Statics textbook by R.C. Hibbeler<dt-cite key="hibbeler2017"></dt-cite>.</figcaption>

      </figure>
       

     To calculate the coordinate direction angles, we first obtain the directional cosines. 
     <d-math block class = "center">    
      \cos(\alpha) = \frac{A_x}{A}, \:\: \cos(\beta) = \frac{A_y}{A}, \:\: \cos(\gamma) = \frac{A_z}{A}. 
    </d-math>

  
    Then we can take the inverse cosines to determine the angle. 

    </p>
    <p>
    Let us now try and build an intuition about these coordinate direction angles, and how it relates to the components of a vector. The interactive 
    diagram below plots a vector $$\mathbf{F}$$, and the planes in which the coordinate direction angles live. In the legend you will see the cartesian representation of $$\mathbf{F}$$, along with 
    values for $$\alpha$$, $$\beta$$ and $$\gamma$$, rounded to the nearest integer. Try adjusting the components of $$\mathbf{F}$$ by moving the sliders and observe how the coordinate direction angles change in response.
    You can also pan the diagram to visualise the planes from different perspectives. Here are some things to think about: 
   
    </p>
    <p>
      1. When is $$ 0 < \alpha < 90$$ and when is $$ 90 < \alpha < 180$$? <br>
      2. What about $$\alpha=0, 90, 180$$? Do the same for $$\beta$$ and $$\gamma$$. <br>
      3. Try to find a case where $$\alpha$$ remains fixed while changing the $$y$$ and $$z$$ components of $$\mathbf{F}$$. Why does this happen? <br>
      4. For some practice, try to calculate the coordinate direction angles yourself, rounded to the nearest integer.
    </p>

    <div class="grid-container">
      <p class = "grid-item"> adjust value $$x$$</p>
      <p class = "grid-item"> adjust value $$y$$</p>
      <p class = "grid-item"> adjust value $$z$$</p>

      <form class = "grid-item" oninput="amount.value=rangeInput.value">
          <input type="range" id="rangeInput" name="rangeInput" min="-10" max="10" value="3"oninput="adjustValueX(this.value)">
          <output name="amount" for="rangeInput"></output>
      </form>
      <form class = "grid-item" oninput="amount.value=rangeInput.value">
          <input type="range" id="rangeInput" name="rangeInput" min="-10" max="10" value="4" oninput="adjustValueY(this.value)">
          <output name="amount" for="rangeInput"></output>
      </form>
      <form class = "grid-item" oninput="amount.value=rangeInput.value">
          <input type="range" id="rangeInput" name="rangeInput" min="-10" max="10" value="7" oninput="adjustValueZ(this.value)">
          <output name="amount" for="rangeInput"></output>
      </form>
  </div>

   

   
    <div class='.l-screen' id='myDiv'  style='border: 1px solid rgba(0, 0, 0, 0.2);'><!-- Plotly chart will be drawn inside this DIV --></div>
    <script>

      const scene = new THREE.Scene();
      scene.background = new THREE.Color( 0xffffff );
 
      const canvas = document.getElementById("myDiv")
      const canvasWidth = 0.99*document.getElementById("myDiv").offsetWidth;
      const canvasHeight = 0.5*canvasWidth //document.getElementById("myDiv").offsetHeight;
      console.log(canvasWidth + ' ' +  canvasHeight)
      const camera = new THREE.PerspectiveCamera( 75, canvasWidth / canvasHeight, 0.1, 1000 );
      camera.position.set( 0, 0, 100 );
      camera.lookAt( 0, 0, 0 );

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize( canvasWidth, canvasHeight );
      canvas.appendChild( renderer.domElement );

      //create a blue LineBasicMaterial
      var xAxis = new THREE.Vector3(50, 0, 0);
      var xAxisHead = new THREE.Vector3(5, 0, 0);

      const materialX = new THREE.MeshBasicMaterial( {color: 0x2874A6} );

      var yAxis = new THREE.Vector3(0, 50, 0);
      const materialY = new THREE.MeshBasicMaterial( {color: 0xB03A2E} );

      var zAxis = new THREE.Vector3(0, 0, 50);
      const materialZ = new THREE.MeshBasicMaterial( {color: 0x6C3483} );

      radius = 0.7
      var geometryX = new THREE.CylinderGeometry(radius, radius, xAxis.length(), 32, 4);
      var geometryXHead = new THREE.CylinderGeometry(radius, radius*4, xAxisHead.length(), 32, 4);

      var geometryY = new THREE.CylinderGeometry(radius, radius, yAxis.length(), 32, 4);
      var geometryZ = new THREE.CylinderGeometry(radius, radius, zAxis.length(), 32, 4);

      var cylinderX = new THREE.Mesh(geometryX, materialX);
      var cylinderXHead = new THREE.Mesh(geometryXHead, materialX);

      var cylinderY = new THREE.Mesh(geometryY, materialY);
      var cylinderZ = new THREE.Mesh(geometryZ, materialZ);

      var axis = new THREE.Vector3(0, 1, 0);
      cylinderX.quaternion.setFromUnitVectors(axis, xAxis.clone().normalize());
      cylinderX.position.copy(xAxis.clone().multiplyScalar(0.5));

      cylinderXHead.quaternion.setFromUnitVectors(axis, xAxisHead.clone().normalize());
      cylinderXHead.position.set(70,0,0);

      cylinderY.quaternion.setFromUnitVectors(axis, yAxis.clone().normalize());
      cylinderY.position.copy(yAxis.clone().multiplyScalar(0.5));

      cylinderZ.quaternion.setFromUnitVectors(axis, zAxis.clone().normalize());
      cylinderZ.position.copy(zAxis.clone().multiplyScalar(0.5));



      scene.add( cylinderX ); // bleu
      scene.add( cylinderXHead )
      scene.add( cylinderY );
      scene.add( cylinderZ );

      const axesHelper = new THREE.AxesHelper( 70 );
      scene.add( axesHelper );
      renderer.render( scene, camera );

      controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.listenToKeyEvents( window ); // optional

			//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

			controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
      controls.dampingFactor = 0.05;

      controls.screenSpacePanning = false;

      controls.minDistance = 100;
      controls.maxDistance = 500;

      controls.maxPolarAngle = Math.PI / 2;

      // controls.update();
      animate();

      function animate() {

        requestAnimationFrame( animate );

        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

        render();

      }

      function render() {

        renderer.render( scene, camera );

      }
      
              
    </script>
    
    <aside>You may notice that the head of the vector has a dot instead of an arrow. This is a limitation of the library used.</aside>


  </d-article>

  <d-appendix>

    <h3>Contributions</h3>
    <p>The article was created in full by Shane Josias. The Distill web framework was used for styling. </p>

    <!-- <h3>Reviewers</h3> -->
    <!-- <p>Some text with links describing who reviewed the article.</p> -->

    <d-bibliography src="bibliography.bib"></d-bibliography>
  </d-appendix>

  <!-- <distill-footer></distill-footer> -->

</body>